#!/bin/bash

function echoerr() { echo $@ 1>&2; }

# ##############################################################################
# Treat command line args
# ##############################################################################
rootFile=
verbose=0
nLevels=-1
language=auto
quiet=0
while [ ! -z "$1" ]; do
    case "$1" in
        -h)
            cat <<EOF
Visalize include dependencies of <file>.

    incvis [flags] <rootFile>

Flags:

  -h                  Show this help message
  -l <auto|cpp|java>  Language style includes to parse (auto: choose by extension)
  -I path[:path[...]] Include directories where to look for
  -n <levels>         Search up to <levels> parent directories of <rootFile>
                      for possible include directory roots (0 meaning '.',
                      1 meaning '..'). Default: up to current directory.
  -q                  Suppress warnings like not finding system libraries

Examples:

    incvis -I .:.. test.c
    incvis -n 5 test.c
EOF
            ;;
        -I|--include)
            shift
            INC=$1
            ;;
        -l|--language)
            shift
            case "$1" in
                auto) ;;
                cpp)  ;;
                java) ;;
                *)
                    echo "Unknown language '$1' specified"'!'
                    ;;
            esac
            language=$1
            ;;
        -n|--nlevels)
            shift
            nLevels=$1
            ;;
        -q|--quiet)
            quiet=1
            ;;
        -v|--verbose)
            verbose=1
            ;;
        *)
            rootFile=$1
            ;;
    esac
    shift
done

### Check root file ###
if [ -z "$rootFile" ]; then
    echoerr -e "\e[31mPlease specify a source-file from which to start as the first argument"'!'"\e[0m"
    exit 1
fi
if [ ! -f "$rootFile" ]; then
    echoerr -e "\e[31mSpecified file ($rootFile) not found"'!'"\e[0m"
    exit 1
fi

rootFolder=${rootFile%/*}
if [ "$rootFolder" == "$rootFile" ]; then
    rootFolder=.
fi
if [ -z "$rootFolder" ]; then
    # This should only happen in rare cases where the file to be analyzed is directly in root ... Who would do that
    rootFolder='/'
fi
rootFileName=${rootFile##*/}

### Check number of levels ###

curPath=$(pwd)
# ${string/substring/replacement}
#     Replace first match of $substring with $replacement. [2]
# ${string//substring/replacement}
#     Replace all matches of $substring with $replacement.
#nLevelsFile=$(cd "$rootFolder" && pwd) # get absolute path
nLevelsFile=$(pwd) # get absolute path
# Note that pwd doesn't print trailing / except of course when in root
if [ "$nLevelsFile" == '/' ]; then
    nLevelsFile=0
else
    nLevelsFile=${nLevelsFile//[^\/]}
    nLevelsFile=${#nLevelsFile}
fi

# # by default search in all paths up to current for includes
# nRelLevelsFile=$(cd "$rootFolder" && pwd)
# nRelLevelsFile=${nRelLevelsFile#$curPath}
# nRelLevelsFile=${nRelLevelsFile//[^\/]}
# nRelLevelsFile=${#nRelLevelsFile}
# nLevels=$nRelLevelsFile

# Don't allow to analyze files in root folder /
if [ $nLevels -ge $nLevelsFile ]; then
    if [ $verbose -eq 1 ]; then
        echoerr -e "\e[37mParent directory levels to search ($nLevels) are as high or higher ($nLevelsFile) than root"'!'"Reducing to one folder below root\e[0m"
    fi
    if [ $nLevelsFile -gt 0 ]; then
        nLevels=$((nLevelsFile-1))
    else
        nLevels=0
    fi
fi



#cd "$rootFolder"

### Check include paths ###

if [ ! -z "$INC" ]; then
    INC=$INC:
fi
INC=$INC:$rootFolder

#INC_ARR=$(echo $INC | tr ":" "\n")
IFS=":" read -a includePaths <<< "$INC"
if [ $verbose -eq 1 ]; then
    echoerr -e "\e[37mInclude Paths (first will be searched first):"
    for path in ${includePaths[@]}; do
        echoerr "    $path"
    done
    echoerr -e "\e[0m"
fi

function getIncludes() {
    local filePath=$1
    local lang=$language
    if [ "$lang" == 'auto' ]; then
        case "${filePath##*.}" in
            'c'|'cpp'|'cxx'|'cu'|'h'|'hpp'|'tpp')
                lang=cpp
                ;;
            'java')
                lang=java
                ;;
            *)
                echoerr -e "\e[31mError unknown file extension of included file '$filePath'"'!'" Please add the extension to this script or specify a language with the -l option"'!'"\e[0m"
                return
                ;;
        esac
    fi
    case "$lang" in
        'cpp')
            # #include "file.h"
            # #include <file.h>  // ignore, because most often in system path (?)
            # ignore commented lines starting: [^/]
            sed -nE 's|^[^/]*#[ \t]*include[ \t]*["<]([^">]*)[">].*|\1|p;' "$filePath"
            ;;
        'java')
            # import java.util.List;
            # ignore system libraries beginning with 'java.' (?) maybe as an option
            # TODO: heed wildcards like import mylib.*;
            sed -nE 's|^[^/]*import[ \t]*([^;]*);.*|\1|p;' "$filePath" | sed 's|\.|/|g; s|$|.java|;'
            ;;
        *)
            echoerr -e "\e[31mNo parsing routine exists for language '$lang' yet"'!'"\e[0m"
            return
            ;;
    esac
}

############################### Begin Main Logic ###############################

searchedPaths=()

# printAllIncludes <source-file> <level>
printAllIncludes() {
    local file level indent includes i path foundPath
    file=$1
    level=$2

    # print current file
    indent=$(($level * 4))
    printf "%.*s" $indent "                             "
    #if [ ! $indent -eq 0 ]; then
    #    printf "+ ";
    #fi
    printf '%s' "$file"

    # search for file in paths to determine if already found and we can stop parsing it
    for path in ${searchedPaths[@]}; do
        if [ "$path" == "$file" ]; then
            printf " -> already loaded"
            return 1
        fi
    done

    # http://stackoverflow.com/questions/19771965/split-bash-string-by-newline-characters
    IFS=$'\n' read -rd '' -a includes <<<"$(getIncludes "$file")"
    searchedPaths+=( "$file" )

    # parse dependencies recursively
    for (( i=0; i<${#includes[@]}; i++ )); do
    {
        includeFile=${includes[i]}
        # try to find file in include paths
        foundPath=
        for path in ${file%/*} ${includePaths[@]}; do
            #echoerr -e "\e[36m path = $path \e[0m"
            if [ -f "$path/$includeFile" ]; then
                foundPath="$path/$includeFile"
                break
            fi
        done

        # if no suitable path found, try upper directories
        if [ ! -f "$foundPath" ]; then
            upperDir=.
            for (( iLevel=0; iLevel<=nLevels; iLevel++ )); do
                includeFileFolder=${includeFile%/*}
                includeFileName=${includeFile##*/}
                foundFiles=$(find "$upperDir/$includeFileFolder" -name "$includeFileName" 2>/dev/null)
                nFiles=$(echo "$foundFiles" | wc -l)
                if [ -z "$foundFiles" ]; then
                    nFiles=0
                fi
                #if [ $verbose -eq 1 ]; then
                #    echoerr -e "\e[37mTrying '$(cd $upperDir && pwd)'. Found $nFiles file(s):\n$foundFiles\e[0m"
                #fi
                if [ $nFiles -eq 1 ]; then
                    incRoot=${foundFiles%%$includeFileName}
                    if [ "${incRoot:${#incRoot}-1:1}" == '/' ]; then
                        incRoot=${incRoot:0:-1}
                    fi
                    includePaths+=( "$incRoot" )
                    if [ $verbose -eq 1 ]; then
                        echoerr -e "\e[37m\nAdding '$incRoot' to include paths.\e[0m"
                    fi
                    foundPath=$incRoot/$includeFileName
                    break
                elif [ $nFiles -gt 1 ]; then
                    if [ $verbose -eq 1 ]; then
                        echoerr -e "\e[31mAmbiguous include paths possible:\n$foundFiles\nSkipping this"'!'"\e[0m"
                    fi
                    break
                fi
                # this is important for find to not return paths like ./../../folder
                if [ "$upperDir" == '.' ]; then
                    upperDir=..
                else
                    upperDir=$upperDir/..
                fi
            done
        fi

        if [ ! -f "$foundPath" ]; then
            if [ $quiet -eq 0 ]; then
                echoerr -e "\n\e[31mCouldn't find '${includes[i]}' in any of the given include paths. Skipping this.\e[0m"
            fi
            continue
        fi

        printf "\n"
        printAllIncludes "$foundPath" $(($2+1))
    }
    done
}

printAllIncludes "$rootFile" 0
printf "\n"
if [ $nLevels -ge 0 ]; then
    ( IFS=':'; echo -e "Include Paths:\n    ${includePaths[*]}\n" )
fi
